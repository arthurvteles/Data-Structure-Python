import copy

puzzle = [[4, 1, 2], [3, 0, 5], [6, 7, 8]]
puzzle_solve = [[0,1,2],[3,4,5],[6,7,8]]
drows = [1,-1,0,0]
dcolumns = [0,0,-1,1]
queue = []
path = []
rows = 3
columns = 3


class Node:
    def __init__(self, puzzle, move, empty_row, empty_column):
        self.puzzle = puzzle
        self.move = move
        self.empty_row = empty_row
        self.empty_column = empty_column
        self.children = []
        self.parent = None
        self.visited = False

    def add_children(self, child):
        # We're going to test to avoid loops
            if self.parent.move == 'Up' and self.move != 'Down' or self.move == 'ROOT':
                if self.parent.move == 'Down' and self.move != 'Up' or self.move == 'ROOT':
                    if self.parent.move == 'Left' and self.move != 'Right' or self.move == 'ROOT':
                        if self.parent.move == 'Right' and self.move != 'Left' or self.move == 'ROOT':
                            self.children.append(child)

    def add_parent(self, parent):
        self.parent = parent

def build_tree():
    global queue
    global puzzle

    tree_root = Node(puzzle,'ROOT', 2, 2)
    queue.append(tree_root)
    return tree_root

aux = build_tree()


def explore_neighbour(actual_node):
    global puzzle_solve
    global drows
    global dcolumns
    global rows
    global columns
    global queue
    global path

    result = 0

    for i in range(4):
        puzzle_aux = copy.deepcopy(actual_node.puzzle)
        rr = actual_node.empty_row + drows[i] - 1
        rc = actual_node.empty_column + dcolumns[i] - 1

        if rr >= 0 and rr < rows and rc >= 0 and rc < columns:
            temp = copy.deepcopy(puzzle_aux[rr][rc])
            puzzle_aux[rr][rc] = 0
            puzzle_aux[actual_node.empty_row - 1][actual_node.empty_column - 1] = temp

            if drows[i] == 1:
                move_aux = 'Up'
            elif drows[i] == -1:
                move_aux = 'Down'
            elif dcolumns[i] == 1:
                move_aux = 'Left'
            else:
                move_aux = 'Right'

            if puzzle_aux == puzzle_solve:
                new_node = Node(puzzle_aux, move_aux, rr, rc)
                new_node.add_parent(actual_node)
                actual_node.add_children(new_node)
                path.append(new_node)
                result = -1
            else:
                new_node = Node(puzzle_aux, move_aux, rr, rc)
                new_node.add_parent(actual_node)
                actual_node.add_children(new_node)
                queue.append(new_node)

    del queue[0]
    return result


result = 0
i = 0
while result != -1:
    node_aux = queue[0]
    result = explore_neighbour(node_aux)
    i += 1
